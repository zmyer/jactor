/*
 * Created on 7/02/2006
 *
 * To change the template for this generated file go to
 * Window - Preferences - Java - Code Generation - Code and Comments
 */
package au.com.terabit.ssl;

import au.com.terabit.jproactor.AsynchChannel;
import au.com.terabit.jproactor.AsynchChannelHandler;
import au.com.terabit.jproactor.AsynchChannelHandlerFactory;
import au.com.terabit.jproactor.AsynchReadHandler;
import au.com.terabit.jproactor.AsynchWriteHandler;
import au.com.terabit.jproactor.OpAccept;
import au.com.terabit.jproactor.OpConnect;
import au.com.terabit.jproactor.OpRead;
import au.com.terabit.jproactor.OpTimer;
import au.com.terabit.jproactor.OpWrite;
import java.nio.ByteBuffer;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLEngine;
import javax.net.ssl.SSLEngineResult;
import javax.net.ssl.SSLException;
import javax.net.ssl.SSLSession;

//import java.nio.channels.SelectableChannel;
//import java.nio.channels.SocketChannel;

//import java.nio.channels.SelectableChannel;
//import java.nio.channels.SocketChannel;

/**
 * @author Alexander Libman
 * @author Yevgeny Libman
 *
 *         Copyright &copy; 2003 Terabit Pty Ltd. All rights reserved.
 *
 *         Notes: We have deal with 3 type of buffers a) raw (network) buffers b) channel
 *         application data buffers c) user buffers
 *
 *         From SSLEngine doc: " The SSLEngine produces/consumes complete SSL/TLS packets only, and
 *         does not store application data internally between calls to wrap()/unwrap(). "
 *
 *         That explains why we have to support channel application data bufferes and can not
 *         exchange data between raw networks bufffers and user buffers.
 */

// TODO: 17/5/15 by zmyer
public class SSLAsynchChannel
    extends AsynchChannel
    implements AsynchReadHandler,
    AsynchWriteHandler,
    AsynchChannelHandler {
    // Events generated by raw channel
    private final static int EV_RAW_READ_FINISHED = 0x0001;
    private final static int EV_RAW_WRITE_FINISHED = 0x0002;
    private final static int EV_RAW_CLOSED = 0x0004;

    // Events generated by user
    private final static int EV_USER_READ_STARTED = 0x0010;
    private final static int EV_USER_WRITE_STARTED = 0x0020;
    private final static int EV_USER_CLOSED = 0x0040;

    // SSLEngine outgoing status flags
    private final static int OUT_OVERFLOW = 0x0001; // m_rawOutBuffer is full
    private final static int OUT_UNDERFLOW = 0x0002; // m_appOutBuffer is empty
    private final static int OUT_CLOSING = 0x0004; // closeOutbound called
    private final static int OUT_DONE = 0x0008; // outbound is done
    private final static int OUT_EOS = 0x0010; // raw Output is closed

    // SSLEngine incoming status flags
    private final static int IN_OVERFLOW = 0x0100;  // m_appInBuffer is full
    private final static int IN_UNDERFLOW = 0x0200;  // no full packet in m_rawInBuffer 
    private final static int IN_CLOSING = 0x0400;  // closeInbound called
    private final static int IN_DONE = 0x0800;  // inbound is done
    private final static int IN_EOS = 0x1000;  // end of raw Input Data

    //  true  for CLIENT mode
    //  false for SERVER mode
    boolean m_mode;

    SSLContext m_context;
    SSLEngine m_engine;

    SSLEngineResult m_sslResult = null;
    SSLEngineResult.HandshakeStatus m_handshakeStatus =
        SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING;

    boolean m_flgActive = false;
    int m_events = 0;

    int m_inStatus;
    int m_outStatus;

    ByteBuffer m_rawOutBuffer;
    ByteBuffer m_rawInBuffer;

    ByteBuffer m_appOutBuffer;
    ByteBuffer m_appInBuffer;

    //	 for raw input/output
    AsynchChannel m_rawChannel;

    //   factory for producing application handler	
    AsynchChannelHandlerFactory m_usrFactory = null;

    boolean m_debug = false;

    public SSLAsynchChannel(boolean mode,
        SSLContext ctx,
        AsynchChannelHandlerFactory usrFactory) {
        m_usrFactory = usrFactory;

        m_mode = mode;
        m_context = ctx;

        m_engine = m_context.createSSLEngine();
        m_engine.setUseClientMode(m_mode);

        SSLSession session = m_engine.getSession();
        m_handshakeStatus = SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING;

        m_appInBuffer = ByteBuffer.allocate(session.getApplicationBufferSize());
        m_appOutBuffer = ByteBuffer.allocate(session.getApplicationBufferSize());

        m_rawOutBuffer = ByteBuffer.allocate(session.getPacketBufferSize());
        m_rawInBuffer = ByteBuffer.allocate(session.getPacketBufferSize());

        m_rawInBuffer.limit(0);  // input buffers are empty as producers
        m_appInBuffer.limit(0);  // while output buffers has full space as consumers

        m_outStatus = OUT_UNDERFLOW;
        m_inStatus = IN_UNDERFLOW;

    }

    //
    //   Interface AsynchChannelHandler
    //   is called when raw Asynch Channel 
    //   attaches and closes 
    //
    public void channelAttached(AsynchChannel channel) throws Exception {
        m_rawChannel = channel;

        m_engine.beginHandshake();
        m_handshakeStatus = m_engine.getHandshakeStatus();

        AsynchChannelHandler handler = m_usrFactory.createChannelHandler();
        this.setChannelHandler(handler);
    }

    public void channelClosed(AsynchChannel channel) throws Exception {
        m_lock.lock();
        try {
            if (channel == m_rawChannel) {
                // no need to use anymore raw channel
                m_rawChannel = null;
                m_inStatus |= IN_EOS;
                m_outStatus |= OUT_EOS;

                closeEngine(OUT_CLOSING);
                processEvents(EV_RAW_CLOSED);
            }
        } finally {
            m_lock.unlock();
        }
    }

    //
    //   Interface AsynchReadHanlder
    //   is called when read operation on internal asynch channel
    //   finishes
    //
    public void readCompleted(OpRead opRead) throws Exception {
        m_lock.lock();
        try {
            // check precondition
            // when we started read we set m_rawInBuffer to null 
            assert (m_rawInBuffer == null);

            m_rawInBuffer = opRead.getBuffer();

            // set as producer
            m_rawInBuffer.flip();

            if (opRead.getBytesCompleted() != 0) {
                // unwrap  now may be possible
                m_inStatus &= ~IN_UNDERFLOW;
            } else {
                // end of Input Stream
                m_inStatus |= IN_EOS;
            }

            if (opRead.getError() != null) {
                // also end of Input Stream
                m_inStatus |= IN_EOS;
                m_rawChannel.close();
            }

            processEvents(EV_RAW_READ_FINISHED);
        } finally {
            m_lock.unlock();
        }
    }

    //
    //   Interface AsynchWriteHanlder
    //   is called when write operation on internal asynch channel
    //   finishes
    //
    public void writeCompleted(OpWrite opWrite) throws Exception {
        m_lock.lock();
        try {
            // check precondition
            // when we started write we set m_rawOutBuffer to null 
            assert (m_rawOutBuffer == null);
            m_rawOutBuffer = opWrite.getBuffer();

            // set buffer as consumer
            m_rawOutBuffer.compact();

            if (opWrite.getBytesCompleted() != 0) {
                // wrap may be possible
                m_outStatus &= ~OUT_OVERFLOW;
            } else {
                // raw output is impossible
                m_outStatus |= OUT_EOS;
            }

            if (opWrite.getError() != null) {
                // also raw output is impossible
                m_outStatus |= OUT_EOS;
                m_rawChannel.close();
            }

            processEvents(EV_RAW_WRITE_FINISHED);
        } finally {
            m_lock.unlock();
        }
    }

    //
    //   Interface AsynchChannel
    //

    protected boolean startClose() {
        try {
            //int how = OUT_DONE;
            //closeEngine (how);

            processEvents(EV_USER_CLOSED);

            return true;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return false;
    }

    protected void startRead(OpRead op) throws Exception {
        if (m_appInBuffer.hasRemaining()) {
            executeListAndDispatch(m_readQue);
        }

        if (m_rawInBuffer != null) {
            processEvents(EV_USER_READ_STARTED);
        }
    }

    protected void startWrite(OpWrite op) throws Exception {
        if (m_appOutBuffer.hasRemaining()) {
            executeListAndDispatch(m_writeQue);
        }

        if (m_rawOutBuffer != null) {
            processEvents(EV_USER_WRITE_STARTED);
        }
    }

    protected void startAccept(OpAccept op) throws Exception {
        throw new SSLException("SSLASynchChannel::startAccept - not supported");
    }

    protected void startConnect(OpConnect op) throws Exception {
        throw new SSLException("SSLASynchChannel::startConnect - not supported");
    }

    public void startTimer(OpTimer op) throws Exception {
        m_lock.lock();
        try {
            if (m_rawChannel != null) {
                m_rawChannel.startTimer(op);
            }
        } finally {
            m_lock.unlock();
        }
    }

    protected int finishRead(OpRead op) throws Exception {
        int rc = copyBuffer(m_appInBuffer, op.getBuffer());
        if (rc > 0) {
            // unwrap may be possible now
            m_inStatus &= ~IN_OVERFLOW;
        } else if (rc == 0) {
            if ((m_inStatus & (IN_CLOSING | IN_DONE)) != 0) {
                rc = -1; // no more datareturn -1;
            }
        }
        return rc;
    }

    protected int finishWrite(OpWrite op) throws Exception {
        if ((m_outStatus & (OUT_CLOSING | OUT_DONE | OUT_EOS)) != 0) {
            return -1; // no more data can be send
        }

        int rc = copyBuffer(op.getBuffer(), m_appOutBuffer);
        if (rc > 0) {
            // wrap may be possible now;
            m_outStatus &= ~OUT_UNDERFLOW;
        }
        return rc;
    }

    protected boolean finishConnect(OpConnect op) throws Exception {
        throw new SSLException("executeConnect not implemented");
    }

    protected AsynchChannel finishAccept(OpAccept accept) throws Exception {
        throw new SSLException("executeAccept not implemented");
    }

    /**
     * @param srcBuf
     * @param dstBuf
     * @return N > 0 number bytes copied 0   srcBuf is empty ( position == limit) -1   dstBuf has no
     * space ( position == limit)
     */
    private int copyBuffer(ByteBuffer srcBuf, ByteBuffer dstBuf) {
        int dstLen = dstBuf.remaining();
        if (dstLen == 0) {
            return -1;
        }

        int srcLen = srcBuf.remaining();
        if (srcLen == 0) {
            return 0;
        }
        int len = Math.min(srcLen, dstLen);
        int srcLimit = srcBuf.limit();

        // set src limit to prevent exception
        srcBuf.limit(srcBuf.position() + len);

        // do copy from src to dst
        dstBuf.put(srcBuf);

        // restore original src limit
        srcBuf.limit(srcLimit);

        return len;
    }

    //
    //   Own methods, helpers, etc
    //
    private void processEvents(int events) throws Exception {
        m_events |= events;

        if (m_flgActive) {
            return;
        }

        try {
            m_flgActive = true;

            while (m_events != 0) {
                events = m_events;
                m_events = 0;

                doStateMachine(events);

                if ((m_inStatus & (IN_CLOSING | IN_DONE | IN_EOS)) != 0 &&
                    (m_outStatus & (OUT_CLOSING | OUT_DONE)) != 0) {
                    this.setClosing();
                }
                executeListAndDispatch(m_readQue);
                executeListAndDispatch(m_writeQue);
            }

            checkForClose();

            // if raw write is not in progress and 
            // raw ouput buffer is not empty
            int rcw = initiateRawWrite();

            // if raw read is not in progress and  
            // raw input buffer is empty    
            int rcr = initiateRawRead();

            if (rcr == 0 || rcw == 0) {
                return;
            }

            if ((m_rawChannel != null) &&
                (m_inStatus & (IN_DONE | IN_EOS)) != 0 &&
                (m_outStatus & (OUT_DONE | OUT_EOS)) != 0
                ) {
                m_rawChannel.close();
            }
        } finally {
            m_flgActive = false;
        }
    }

    /**
     * @param how specify how to close - combination of OUT_CLOSING  close outbound IN_CLOSING close
     * inbound
     * @return 1 - if  engine just closed 0 - if  engine was already closed
     */
    private int closeEngine(int how) {
        boolean rc = false;

        if ((how & OUT_CLOSING) != 0) {
            if ((m_outStatus & (OUT_CLOSING | OUT_DONE)) == 0) {
                m_outStatus |= OUT_CLOSING;
                rc = true;
                m_engine.closeOutbound();
            }
        }

        if ((how & IN_CLOSING) != 0) {
            if ((m_inStatus & (IN_CLOSING | IN_DONE)) == 0) {
                m_inStatus |= IN_CLOSING;
                rc = true;
                try {
                    m_engine.closeInbound();
                } catch (Exception x) {
                    x.printStackTrace();
                }
            }
        }

        if (!rc) {
            return 0;
        }

        m_handshakeStatus = m_engine.getHandshakeStatus();

        if (m_engine.isInboundDone()) {
            m_inStatus |= IN_DONE;
        }

        if (m_engine.isOutboundDone()) {
            m_outStatus |= OUT_DONE;
        }

        m_sslResult = new SSLEngineResult(SSLEngineResult.Status.OK,
            m_handshakeStatus,
            0,
            0);

        if (m_debug) {
            printStatus("CloseEngine "
                + (((how & IN_CLOSING) != 0) ? "IN " : "")
                + (((how & OUT_CLOSING) != 0) ? "OUT " : "")
            );
        }
        return 1;
    }

    private void printStatus(String text) {
        if (!m_debug)
            return;

        System.out.print(m_mode ? "Client " : "Server ");
        if (m_sslResult != null) {
            System.out.println(text + " : " + m_sslResult.toString());
        } else {
            System.out.println(text + " : HandshakeStatus=" + m_handshakeStatus.toString());
        }
    }

    private void doStateMachine(int events) throws Exception {
        int rc = 0;
        do {
            rc = 0;
            switch (m_handshakeStatus) {
                case NEED_TASK:
                    rc = doTask();
                    break;
                case NEED_WRAP:
                    rc = doWrap();
                    break;
                case NEED_UNWRAP:
                    rc = doUnwrap();
                    break;
                case NOT_HANDSHAKING:
                case FINISHED:
                    if ((m_outStatus & OUT_UNDERFLOW) == 0) {
                        rc = doWrap();
                    }

                    if ((rc == 0) && ((m_inStatus & IN_OVERFLOW) == 0)) {
                        rc = doUnwrap();
                    }

                    if ((rc == 0) && this.isClosed()) {
                        rc = closeEngine(OUT_CLOSING);
                    }
                    break;
                default:
                    System.out.print("doStateMachine::invalid handshake Status\n");
                    rc = closeEngine(OUT_CLOSING | IN_CLOSING);
                    break;
            }
        }
        while (rc != 0);
    }

    private int doTask() throws Exception {
        m_lock.unlock();
        try {
            Runnable task;
            while ((task = m_engine.getDelegatedTask()) != null) {
                task.run();
            }
        } catch (Exception e) {
            e.printStackTrace();
            closeEngine(OUT_CLOSING);
            return -1;
        } finally {
            m_lock.lock();
        }
        m_handshakeStatus = m_engine.getHandshakeStatus();
        return 1;
    }

    /**
     * @return 1  unwrap is done 0  raw read is started , continue later on completion -1 errors ,
     * raw channel is closed or inbound is done
     * @throws Exception
     */
    private int doUnwrap() throws Exception {
        if ((m_inStatus & IN_DONE) != 0 ||
            (m_inStatus & IN_UNDERFLOW) != 0) {
            return 0;
        }

        assert (m_rawInBuffer != null);

        m_appInBuffer.compact();   // buffer as consumer
        try {
            m_sslResult = m_engine.unwrap(m_rawInBuffer, m_appInBuffer);
        } catch (Exception e) {
            e.printStackTrace();
            closeEngine(OUT_CLOSING);
            return -1;
        } finally {
            if (!m_rawInBuffer.hasRemaining())  // raw Buffer is empty
            {
                m_inStatus |= IN_UNDERFLOW;      // equal to future IN_UNDERFLOW
            }

            m_appInBuffer.flip();      // buffer as producer
        }

        SSLEngineResult.Status status = m_sslResult.getStatus();
        m_handshakeStatus = m_sslResult.getHandshakeStatus();

        printStatus("Unwrap");

        switch (status) {
            case OK:
                return 1;            // continue state machine

            case BUFFER_UNDERFLOW:   // not enough data in m_rawInBuffer
                m_inStatus |= IN_UNDERFLOW;
                return 0;

            case BUFFER_OVERFLOW:    // m_appInBuffer full, user must read
                m_inStatus |= IN_OVERFLOW;
                return 0;

            case CLOSED:
                m_inStatus |= IN_DONE;
                return 1;

            default:
                break;
        }

        closeEngine(IN_DONE);
        return -1;
    }

    /**
     * @return 1 wrap is done 0 raw write is started , continue later on completion or no need to
     * call wrap -1 errors , raw channel is closed or outbound is done
     * @throws Exception
     */
    private int doWrap() throws Exception {
        if ((m_outStatus & OUT_DONE) != 0 ||
            (m_outStatus & OUT_OVERFLOW) != 0) {
            return 0;
        }

        assert (m_rawOutBuffer != null);

        m_appOutBuffer.flip();      // set buffer as producer
        try {
            m_sslResult = m_engine.wrap(m_appOutBuffer, m_rawOutBuffer);
        } catch (Exception e) {
            e.printStackTrace();
            closeEngine(OUT_CLOSING);
            return -1;
        } finally {
            if (!m_appOutBuffer.hasRemaining()) {
                m_outStatus |= OUT_UNDERFLOW;
            }
            m_appOutBuffer.compact();   // restore buffer as consumer
        }

        SSLEngineResult.Status status = m_sslResult.getStatus();
        m_handshakeStatus = m_sslResult.getHandshakeStatus();

        printStatus("Wrap");

        switch (status) {
            case OK:
                return 1;            // continue state machine

            case BUFFER_UNDERFLOW:   // user must send more ??
                m_outStatus |= OUT_UNDERFLOW;
                return 0;

            case BUFFER_OVERFLOW:    // m_rawOutBuffer full, must flush it
                m_outStatus |= OUT_OVERFLOW;
                return 0;

            case CLOSED:
                m_outStatus |= OUT_DONE;
                return 1;

            default:
                break;
        }

        closeEngine(OUT_CLOSING);
        return -1;
    }

    /**
     * this method should be called under locked m_lock
     *
     * @return 2  nothing to do, raw Input Buffer is full 0  if raw read is initiated or already was
     * initiated -1  raw channel is closed or exceptions (in any case -1 means raw channel could not
     * be used)
     */
    private int initiateRawRead() {
        if (((m_inStatus & (IN_DONE | IN_EOS)) != 0) ||
            (m_rawChannel == null)) {
            return -1;  // read impossible or peer closed
        }

        if (m_rawInBuffer == null) {
            return 0;    // raw read already active
        }

        if (!m_rawInBuffer.hasRemaining())  // raw Buffer is empty
        {
            m_inStatus |= IN_UNDERFLOW;      // equal to future IN_UNDERFLOW
        }

        if ((m_inStatus & IN_UNDERFLOW) == 0) // not IN_UNDERFLOW
        {
            return 2;   // nothing todo
        }

        ByteBuffer buf = m_rawInBuffer;
        m_rawInBuffer = null;

        try {
            // input buffer can have remain data n=limit-position
            // shift these data to the beggining 
            // and set:  position=n  limit=capacity

            buf.compact();  // buffer as consumer
            m_rawChannel.read(buf, this);
            return 0;
        } catch (Exception e) {
            buf.flip();    // buffer as producer
            m_rawInBuffer = buf;
            m_rawChannel.close();
        }
        return -1;
    }

    /**
     * this method should be called under locked m_lock
     *
     * @return 2  nothing to do, all raw data is already written 0  if raw write initiated or
     * already was initiated -1  raw channel is closed or exceptions (in any case -1 means raw
     * channel could not be used)
     */
    private int initiateRawWrite() {
        if (((m_outStatus & OUT_EOS) != 0) || (m_rawChannel == null)) {
            return -1;  // write impossible or peer closed
        }

        if (m_rawOutBuffer == null) {
            return 0;    // raw write already active
        }

        if (m_rawOutBuffer.remaining() == m_rawOutBuffer.capacity()) {
            return 2;  // nothing to write
        }

        m_outStatus |= OUT_OVERFLOW;      // equal to future OUT_OVERFLOW

        ByteBuffer buf = m_rawOutBuffer;
        m_rawOutBuffer = null;

        try {
            // output buffer filled up to position
            // we have to flip before writing

            buf.flip();    // buffer as producer
            m_rawChannel.write(buf, this);
            return 0;
        } catch (Exception e) {
            buf.compact();   // buffer as consumer
            m_rawOutBuffer = buf;
            m_rawChannel.close();
        }
        return -1;
    }

}
